// shared/schemas/episode.proto

syntax = "proto3";

package omega_rag.memory;

option go_package = "https://git.darkcloud.ca/yoshmaista/omega-rag/proto/memory";
option java_package = "com.omegarag.proto.memory";
option java_multiple_files = true;

import "google/protobuf/timestamp.proto";

// Represents a complete task execution episode
message Episode {
  // Unique identifier for the episode
  optional string id = 1;

  // Timestamp when episode was created
  optional google.protobuf.Timestamp created_at = 2;

  // Timestamp when episode was last updated
  optional google.protobuf.Timestamp updated_at = 3;

  // The problem or query that initiated this episode 
  optional Problem problem = 4;

  // The plan generated to solve the problem
  optional Plan plan = 5;

  // The outcome of the episode
  optional Outcome outcome = 7;

  // Metadata about the episode
  optional EpisodeMetadata metadata = 8;

  // Vector embedding of the episode (for similarity search)
  repeated float embedding = 9 [packed = true];
}

// The initial problem description
message Problem {
  // The user's query or task description
  optional string description = 1;

  // Problem category/type
  optional string category = 2;

  // Difficulty level (1-10)
  optional int32 difficulty = 3;

  // Domain or subject area
  optional string domain = 4;

  // Any additional context
  map<string, string> context = 5;
}

// The generated plan
message Plan {
  // Unique plan identifier
  optional string plan_id = 1;

  // Overall strategy description
  optional string strategy = 2;

  // List of subtasks
  repeated SubTask subtasks = 3;

  // Estimated total time (seconds)
  optional float estimated_duration = 4;

  // Confidence score (0.0-1.0)
  optional float confidence = 5;
}

// A single subtask in the plan
message SubTask {
  // Subtask identifier
  optional string id = 1;

  // Subtask description
  optional string description = 2;

  // Tool or action to use
  optional string tool = 3;

  // Tool parameters
  map<string, string> parameters = 4;

  // Dependencies (IDs of subtasks that must complete first)
  repeated string dependencies = 5;

  // Expected output type
  optional string output_type = 6;
}

// The execution trajectory
message Trajectory {
  // List of executed steps
  repeated ExecutionStep steps = 1;

  // Total execution time (seconds)
  optional float total_duration = 2;

  // Number of tool calls
  optional int32 tool_call_count = 3;

  // Number of retries/corrections
  optional int32 retry_count = 4;
}

// A single execution step
message ExecutionStep {
  // Step number
  optional int32 step_number = 1;
  
  // Timestamp when step started
  optional google.protobuf.Timestamp started_at = 2;

  // Timestamp when step completed
  optional google.protobuf.Timestamp completed_at = 3;

  // The subtask being executed
  optional string subtask_id = 4;

  // Tool used
  optional string tool = 5;

  // Input to the tool
  optional string input = 6;

  // Output from the tool
  optional string output = 7;

  // Status of the step
  optional StepStatus status = 8;

  // Error message if any
  optional string error_message = 9;

  // Duration in seconds
  optional float duration = 10;
}

// Status of an execution step
enum StepStatus {
  STEP_STATUS_UNSPECIFIED = 0;
  STEP_STATUS_PENDING = 1;
  STEP_STATUS_RUNNING = 2;
  STEP_STATUS_SUCCESS = 3;
  STEP_STATUS_FAILED = 4;
  STEP_STATUS_SKIPPED = 5;
  STEP_STATUS_RETRY = 6;
}

// The outcome fo the episode
message Outcome {
  // Whether the task was successful
  optional bool success = 1;

  // Final result or answer
  optional string result = 2;

  // Reward score (-1.0 to 1.0)
  optional float reward = 3;

  // Quality score (0.0-1.0)
  optional float quality_score = 4;

  // User satisfaction (0.0-1.0, if available)
  optional float user_satisfaction = 5;

  // Failure reason if unsuccessful
  optional string failure_reason = 6;

  // Metrics collected during execution
  map<string, float> metrics = 7;
}

// Metadata about the episode
message EpisodeMetadata {
  // Agent version that created this episode
  optional string agent_version = 1;

  // Model used for planning
  optional string planner_model = 2;

  // Session ID this episode belongs to
  optional string session_id = 3;

  // User ID (if available)
  optional string user_id = 4;

  // Tags for categorization
  repeated string tags = 5;

  // Number of times this episode has been retrieved
  optional int32 retrieval_count = 6;

  // Number of times this episode led to usuccessful outcomes when retrieved
  optional int32 success_influence_count = 7;

  // Whether this episode has been consolidated into semantic memory
  optional bool consolidated = 8;

  // Archived flag
  optional bool archived = 9;

  // Custom metadata fields
  map<string, string> custom_fileds = 10;
}

// Request to store an episode
message StoreEpisodeRequest {
  optional Episode episode = 1;

  // Whether to generate embedding automatically
  optional bool auto_embed = 2;

  // Collection/partition to store in
  repeated string collection = 3;
}

// Repsonse from storing an episode
message StoreEpisodeResponse {
  // ID of the stored episode
  optional string episode_id = 1;

  // Whether the operation was successful
  optional bool success = 2;

  // Error message if any
  repeated string error_message = 3;

  // Generated embedding if auto_embed was true
  repeated float embedding = 4 [packed = true];
}

// Request to retrieve episodes by ID
message GetEpisodeRequest {
  // Episode ID
  optional string episode_id = 1;

  // Whether to include the full trajectory
  optional bool include_trajectory = 2;

  // Collection to retrieve from
  repeated string collection = 3;
}

// Response containing an episode
message GetEpisodeResponse {
  optional Episode episode = 1;

  optional bool found = 2;

  repeated string error_message = 3;
}

// Request to search for similar episodes
message SearchEpisodesRequest {
  // Query embedding or problem description
  oneof query {
    repeated float query_embedding =1 [packed = true];
    string query_text = 2;
  }

  // Number of results to return
  repeated int32 top_k = 3;

  // Minimum similarity threshold (0.0-1.0)
  optional float min_similarity = 4;

  // Filter criteria
  optional EpisodeFilter filter = 5;

  // Collection to search in
  repeated string collection = 6;
}

// Filter for episode search
message EpisodeFilter {
  // Filter by success
  optional bool success_only = 1;

  // Filter by category
  repeated string categories = 2;

  // Filter by domain
  repeated string domains = 3;

  // Filter by tags
  repeated string tags = 4;

  // Filter by minimum reward
  optional float min_reward = 5;

  // Filter by minimum quality score
  optional float min_quality = 6;

  // Filter by date range
  optional google.protobuf.Timestamp created_after = 7;
  optional google.protobuf.Timestamp created_before = 8;

  // Filter by session ID
  optional string session_id = 9;

  // Exclude archived episodes
  optional bool exclude_archived = 10;
}

// Response containing search results
message SearchEpisodesResponse {
  // Matching episodes with similarity scores
  repeated EpisodeSearchResult results = 1;

  // Total number of matches found
  repeated int32 total_matches = 2;

  // Search duration in milliseconds
  optional float search_duration_ms = 3;

  repeated string error_message = 4;
}

// A single search result
message EpisodeSearchResult {
  // The episode
  optional Episode episode = 1;

  // Similarity score (0.0-1.0)
  optional float similarity = 2;

  // Rank in results
  optional int32 rank = 3;
}

// Batch operations
message BatchStoreEpisodesRequest {
  repeated Episode episodes = 1;

  repeated bool auto_embed = 2;

  repeated string collection = 3;
}

message BatchStoreEpisdoesResponse {
  repeated string episode_ids = 1;

  optional int32 success_count = 2;

  optional int32 failure_count = 3;

  repeated string error_messages = 4;
}

// Update episode metadata
message UpdateEpisodeMetadataRequest {
  optional string episode_id = 1;

  repeated EpisodeMetadata metadata = 2;

  // Fields to update (if empty, update all)
  repeated string update_mask = 3;

  repeated string collection = 4;
}

message UpdateEpisodeMetadataResponse {
  optional bool success = 1;

  repeated string error_message = 2;
}

// Delete episodes
message DeleteEpisdoeRequest {
  optional string episode_id = 1;

  repeated string collection = 2;

  // Soft delete (archive) or hard delete
  optional bool soft_delete = 3;
}

message DeleteEpisodeResponse {
  optional bool success = 1;

  repeated string error_message = 2;
}

// Statistics about episodes
message EpisodeStatistics {
  optional int64 total_episodes = 1;
  
  optional int64 successful_episodes = 2;

  optional int64 failed_episodes = 3;

  optional float average_reward = 4;

  optional float average_quality = 5;

  optional float average_duration = 6;

  map<string, int64> episodes_by_category = 7;

  map<string, int64> episodes_by_domain = 8;
}

message GetStatisticsRequest {
  repeated string collection = 1;

  repeated EpisodeFilter filter = 2;
}

message GetStatisticsResponse {
  repeated EpisodeStatistics statistics = 1;

  repeated string error_message = 2;
}
